% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utilities-data-combined.R
\name{calculateResiduals}
\alias{calculateResiduals}
\title{Calculate residuals for datasets in \code{DataCombined}}
\usage{
calculateResiduals(dataCombined, scaling, xUnit = NULL, yUnit = NULL)
}
\arguments{
\item{dataCombined}{A single instance of \code{DataCombined} class containing both
observed and simulated datasets to be compared.}

\item{scaling}{A character specifying the scaling method for residual calculation.
Must be either \code{tlf::Scaling$lin} for linear residuals
(simulated - observed) or \code{tlf::Scaling$log} for logarithmic residuals
(log(simulated) - log(observed)).}

\item{xUnit, yUnit}{Target units for \code{xValues} and \code{yValues}, respectively. If
not specified (\code{NULL}), the first existing unit in the respective
columns will be selected as the common unit. For available dimensions
and units, see \code{ospsuite::ospDimensions} and \code{ospsuite::ospUnits}.}
}
\value{
A tibble (data frame) containing paired observed-simulated data with calculated
residuals. The following columns will be present:

\describe{
\item{group}{Grouping identifier from the original DataCombined object}
\item{name}{Name of the observed dataset}
\item{nameSimulated}{Name of the paired simulated dataset}
\item{xValues}{X-axis values (typically time points) from observed data}
\item{xUnit}{Unit of x-values after harmonization}
\item{xDimension}{Dimension of x-values (e.g., "Time")}
\item{yValuesObserved}{Observed y-values at each x-point}
\item{yValuesSimulated}{Simulated y-values interpolated to observed x-points}
\item{residualValues}{Calculated residuals (method depends on scaling parameter)}
\item{yUnit}{Unit of y-values after harmonization}
\item{yDimension}{Dimension of y-values (e.g., "Concentration")}
\item{yErrorValues}{Error values from observed data (if available)}
\item{yErrorType}{Type of error (e.g., "SD", "SE")}
\item{yErrorUnit}{Unit of error values}
\item{lloq}{Lower limit of quantification (if available)}
}

Returns \code{NULL} with a warning if no pairable datasets are found.
}
\description{
Computes residuals between observed and simulated datasets by interpolating
simulated values to observed time points and calculating the difference
according to the specified scaling method.
}
\details{
\subsection{Algorithm Overview}{

The function performs the following steps to calculate residuals:
\enumerate{
\item \strong{Data Validation and Pairing}: For each group in the data, the function
pairs observed datasets with simulated datasets. Any unpaired datasets
(observed without corresponding simulated or vice versa) are removed.
\item \strong{Unit Harmonization}: All datasets are converted to common units
(specified by \code{xUnit} and \code{yUnit} parameters) to ensure consistent
calculations.
\item \strong{Interpolation}: For each observed-simulated pair, the function uses
linear interpolation to estimate simulated values at the exact time points
where observations exist:
\itemize{
\item With 2+ simulated points: Linear interpolation via \code{stats::approx()}
\item With 1 simulated point: Direct matching for identical x-values only
\item With 0 simulated points: All residuals set to NA
}
\item \strong{Residual Calculation}: Residuals are computed based on the scaling method:
\itemize{
\item \strong{Linear scaling} (\code{tlf::Scaling$lin}):
\deqn{residual = y_{simulated} - y_{observed}}
\item \strong{Logarithmic scaling} (\code{tlf::Scaling$log}):
\deqn{residual = \log(y_{simulated}) - \log(y_{observed})}
Note: For log scaling, a small epsilon value is used to handle zero or
near-zero values safely.
}
}
}

\subsection{Important Notes}{
\itemize{
\item Residuals can only be computed when both observed and simulated data exist
for the same group
\item Interpolation does not extrapolate beyond the range of simulated data
(returns NA for observed points outside simulated time range)
\item NA residual values are automatically filtered from the output
\item When multiple observed/simulated datasets exist in a group, all possible
pairs are evaluated
}
}
}
\examples{
# simulated data
simFilePath <- system.file("extdata", "Aciclovir.pkml", package = "ospsuite")
sim <- loadSimulation(simFilePath)
simResults <- runSimulations(sim)[[1]]
outputPath <- "Organism|PeripheralVenousBlood|Aciclovir|Plasma (Peripheral Venous Blood)"

# observed data
obsData <- lapply(
  c("ObsDataAciclovir_1.pkml", "ObsDataAciclovir_2.pkml", "ObsDataAciclovir_3.pkml"),
  function(x) loadDataSetFromPKML(system.file("extdata", x, package = "ospsuite"))
)
names(obsData) <- lapply(obsData, function(x) x$name)


# Create a new instance of `DataCombined` class
myDataCombined <- DataCombined$new()

# Add simulated results
myDataCombined$addSimulationResults(
  simulationResults = simResults,
  quantitiesOrPaths = outputPath,
  groups = "Aciclovir PVB"
)

# Add observed data set
myDataCombined$addDataSets(obsData$`Vergin 1995.Iv`, groups = "Aciclovir PVB")

calculateResiduals(myDataCombined, scaling = tlf::Scaling$lin)
}
\seealso{
Other data-combined: 
\code{\link{DataCombined}},
\code{\link{convertUnits}()}
}
\concept{data-combined}
