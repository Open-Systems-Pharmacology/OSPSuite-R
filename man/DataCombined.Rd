% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data-combined.R
\docType{class}
\name{DataCombined}
\alias{DataCombined}
\title{Object combining simulated and observed data}
\description{
A class for storing simulated and/or observed in a single dataframe, which
can be further used for visualization methods.

Additionally, it allows:
\itemize{
\item Grouping different (simulated and/or observed) datasets with grouping
labels.
\item Transforming data (with given offsets and scale factors).
}
}
\note{
The molecular weight (in \code{molWeight} column) is in \code{g/mol} units.
}
\examples{

# load the simulation
simFilePath <- system.file("extdata", "Aciclovir.pkml", package = "ospsuite")
sim <- loadSimulation(simFilePath)
simulationResults <- runSimulations(simulations = sim)

# create a new dataset object
dataSet <- DataSet$new(name = "DS")

# created object with datasets combined
myCombDat <- DataCombined$new()
myCombDat$addSimulationResults(simulationResults)
myCombDat$addDataSets(dataSet)

# print the object
myCombDat
}
\section{Super class}{
\code{\link[ospsuite:Printable]{ospsuite::Printable}} -> \code{DataCombined}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{names}}{A vector of unique names of datasets contained in the
\code{DataCombined} class instance.}

\item{\code{groupMap}}{A dataframe specifying which datasets have been grouped
together and the name and the nature (observed or simulated?) of the
data. If a dataset was not assigned to any group, this is denoted by
\code{NA} in the dataframe.}

\item{\code{dataTransformations}}{A dataframe with offset and scale factor
values were specified by the user for each dataset.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-addDataSets}{\code{DataCombined$addDataSets()}}
\item \href{#method-addSimulationResults}{\code{DataCombined$addSimulationResults()}}
\item \href{#method-setGroups}{\code{DataCombined$setGroups()}}
\item \href{#method-setDataTransformations}{\code{DataCombined$setDataTransformations()}}
\item \href{#method-toDataFrame}{\code{DataCombined$toDataFrame()}}
\item \href{#method-print}{\code{DataCombined$print()}}
\item \href{#method-clone}{\code{DataCombined$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addDataSets"></a>}}
\if{latex}{\out{\hypertarget{method-addDataSets}{}}}
\subsection{Method \code{addDataSets()}}{
Adds observed data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$addDataSets(dataSets, newNames = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataSets}}{Instance (or a \code{list} of instances) of the \code{DataSet}
class.}

\item{\code{newNames}}{A string or a list of strings  assigning new names to the
list of instances of the \code{DataSet} class. Note that the datasets whose
names you wish to not change should be specified as \code{NULL} in the list.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{DataCombined} object containing observed data.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addSimulationResults"></a>}}
\if{latex}{\out{\hypertarget{method-addSimulationResults}{}}}
\subsection{Method \code{addSimulationResults()}}{
Add simulated data using instance of \code{SimulationResults} class.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$addSimulationResults(
  simulationResults,
  quantitiesOrPaths = NULL,
  population = NULL,
  individualIds = NULL,
  newNames = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{simulationResults}}{Object of type \code{SimulationResults} produced by
calling \code{runSimulation} on a \code{Simulation} object.}

\item{\code{quantitiesOrPaths}}{Quantity instances (element or list) typically
retrieved using \code{getAllQuantitiesMatching} or quantity path (element or
list of strings) for which the results are to be returned. (optional)
When providing the paths, only absolute full paths are supported (i.e.,
no matching with '*' possible). If \code{quantitiesOrPaths} is \code{NULL}
(default value), returns the results for all output defined in the
results.}

\item{\code{population}}{Population used to calculate the \code{simulationResults}
(optional). This is used only to add the population covariates to the
resulting dataframe.}

\item{\code{individualIds}}{Numeric IDs of individuals for which the results
should be extracted. By default, all individuals from the results are
considered. If the individual with the provided ID is not found, the ID
is ignored.}

\item{\code{newNames}}{A string or a list of strings assigning new names to the
quantities or paths present in the entered \code{SimulationResults} object.
Note that the datasets whose names you wish to not change should be
specified as \code{NULL} in the list.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{DataCombined} object containing simulated data.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-setGroups"></a>}}
\if{latex}{\out{\hypertarget{method-setGroups}{}}}
\subsection{Method \code{setGroups()}}{
Adds grouping information to datasets.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$setGroups(groups)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{groups}}{A named list specifying which datasets belong to which
group. For example, if datsets names are \code{"x"}, \code{"y"}, \code{"z"}, and the
desired groupings for them are respectively \code{"a"} and \code{"b"}, this
argument would be \code{list("x" = "a", "y" = "b")}. Datasets for which no
grouping is to be specified, can be left out of the \code{groups} argument.
The column \code{group} in the dataframe output will be \code{NA} for such
datasets. If you wish to remove already specified grouping for a
dataset, you can specify it as following: \code{list("x" = NA)}. This will
not change any of the other (previously specified) groupings. Note that
if you have specified \code{newNames} while adding datasets using respective
methods, you will need to use these new names to specify group
assignment.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{DataCombined} object with grouped datasets.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-setDataTransformations"></a>}}
\if{latex}{\out{\hypertarget{method-setDataTransformations}{}}}
\subsection{Method \code{setDataTransformations()}}{
Transform raw data with required offsets and scale factors.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$setDataTransformations(
  forNames = NULL,
  xOffsets = 0,
  yOffsets = 0,
  xScaleFactors = 1,
  yScaleFactors = 1
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{forNames}}{A list of names specifying which observed datasets and/or
paths in simulated dataset to transform with the specified
transformations. Default is \code{NULL}, i.e., the transformations, if any
specified, will be applied to all rows of the dataframe.}

\item{\code{xOffsets, yOffsets, xScaleFactors, yScaleFactors}}{Either a single
numeric value or a list of numeric quantities specifying offsets and
scale factors to apply to raw values. The default offset is \code{0}, while
default scale factor is \code{1}, i.e., the data will not be modified. If a
list is specified, it should be the same length as \code{names} argument.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A dataframe with respective raw quantities transformed using specified
offset and scale factor values.
\itemize{
\item For X and Y variables:
\code{newValue = (rawValue + offset) * scaleFactor}
\item For error term:
\code{newErrorValue = rawErrorValue * scaleFactor}
}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-toDataFrame"></a>}}
\if{latex}{\out{\hypertarget{method-toDataFrame}{}}}
\subsection{Method \code{toDataFrame()}}{
A method to extract a dataframe of simulated and/or observed data
(depending on instances of which classes have been added to the object).

Note that the order in which you enter different object doesn't matter
because the returned dataframe is arranged alphabetically by dataset
name.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$toDataFrame()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
In the returned dataframe, the following columns will always be present:

name - group - dataType - xValues - xDimension - xUnit - yValues -
yErrorValues - yDimension - yUnit - yErrorType - yErrorUnit - molWeight
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Print the object to the console
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
