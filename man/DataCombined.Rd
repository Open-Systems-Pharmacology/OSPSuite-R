% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data-combined.R
\docType{class}
\name{DataCombined}
\alias{DataCombined}
\title{Object combining simulated and observed data}
\description{
A class for storing simulated and/or observed in a single dataframe, which
can be further used for visualization methods.

Additionally, it allows:
\itemize{
\item Grouping different (simulated and/or observed) datasets with grouping
labels. If no grouping is specified, name of the dataset is used as a
grouping label.
\item Transforming data (with given offsets and scale factors).
}
}
\examples{

# load the simulation
simFilePath <- system.file("extdata", "Aciclovir.pkml", package = "ospsuite")
sim <- loadSimulation(simFilePath)
simulationResults <- runSimulations(simulations = sim)

# create a new dataset object
dataSet <- DataSet$new()

# created object with datasets combined
myCombDat <- DataCombined$new()
myCombDat$addSimulationResults(simulationResults)
myCombDat$addDataSets(dataSet)

# print the object
myCombDat
}
\section{Super class}{
\code{\link[ospsuite:Printable]{ospsuite::Printable}} -> \code{DataCombined}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{names}}{A vector of unique names of \code{DataSet} objects and/or
quantities or paths from \code{SimulationResuls} object sorted
alphabetically.}

\item{\code{groupMap}}{A dataframe specifying which datasets have been grouped
together and the name and the nature (observed or simulated?) of the
data. If a dataset was not assigned to any group, this is denoted by
\code{NA} in the dataframe.}

\item{\code{dataTransformations}}{A dataframe specifying which offsets and scale
factor values were specified by the user for each dataset.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{DataCombined$new()}}
\item \href{#method-addDataSets}{\code{DataCombined$addDataSets()}}
\item \href{#method-addSimulationResults}{\code{DataCombined$addSimulationResults()}}
\item \href{#method-setDataTransformations}{\code{DataCombined$setDataTransformations()}}
\item \href{#method-toDataFrame}{\code{DataCombined$toDataFrame()}}
\item \href{#method-print}{\code{DataCombined$print()}}
\item \href{#method-clone}{\code{DataCombined$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Initialize a new instance of the class.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$new()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A new (empty) instance of \code{DataCombined} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addDataSets"></a>}}
\if{latex}{\out{\hypertarget{method-addDataSets}{}}}
\subsection{Method \code{addDataSets()}}{
Adds observed data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$addDataSets(dataSets, names = NULL, groups = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataSets}}{Instance (or a \code{list} of instances) of the \code{DataSet}
object(s).}

\item{\code{names}}{A string or a list of string. This argument will be encountered
across different methods:
\itemize{
\item \verb{$setDataTransformations()}: In the context of this method, a list of names
specifying which observed datasets and/or paths in simulated dataset to
transform with the specified transformations. Default is \code{NULL}, i.e., the
transformations, if any specified, will be applied to all rows of the
dataframe.
\item \verb{$addSimulationResults()}: In the context of this method, a list of strings
assigning new names to the quantities or paths present in the entered
\code{SimulationResults} object.
\item \verb{$addDataSets()}: In the context of this method, a list of strings
assigning new names to the list of instances of the \code{DataSet} object.
}

Note that the datasets whose names you wish to not change should be specified
as \code{NULL} in the list.}

\item{\code{groups}}{A string or a list of strings assigning the data set to a
group. If an entry within the list is \code{NULL}, the corresponding data set is
not assigned to any group (and the corresponding entry in the dataframe
will be an \code{NA}). If provided, \code{groups} must have the same length as
\code{dataSets} and/or \code{simulationResults}. If no grouping is specified for any
of the dataset, the column \code{group} in the dataframe output will be all
\code{NA}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{DataCombined} object containing observed data.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addSimulationResults"></a>}}
\if{latex}{\out{\hypertarget{method-addSimulationResults}{}}}
\subsection{Method \code{addSimulationResults()}}{
Add simulated data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$addSimulationResults(
  simulationResults,
  quantitiesOrPaths = NULL,
  population = NULL,
  individualIds = NULL,
  names = NULL,
  groups = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{simulationResults}}{Object of type \code{SimulationResults} produced by
calling \code{runSimulation} on a \code{Simulation} object.}

\item{\code{quantitiesOrPaths}}{Quantity instances (element or list) typically
retrieved using \code{getAllQuantitiesMatching} or quantity path (element or
list of strings) for which the results are to be returned. (optional)
When providing the paths, only absolute full paths are supported (i.e., no
matching with '*' possible). If \code{quantitiesOrPaths} is \code{NULL} (default
value), returns the results for all output defined in the results.}

\item{\code{population}}{population used to calculate the \code{simulationResults}
(optional). This is used only to add the population covariates to the
resulting dataframe.}

\item{\code{individualIds}}{Numeric IDs of individuals for which the results
should be extracted. By default, all individuals from the results are
considered. If the individual with the provided ID is not found, the ID is
ignored.}

\item{\code{names}}{A string or a list of string. This argument will be encountered
across different methods:
\itemize{
\item \verb{$setDataTransformations()}: In the context of this method, a list of names
specifying which observed datasets and/or paths in simulated dataset to
transform with the specified transformations. Default is \code{NULL}, i.e., the
transformations, if any specified, will be applied to all rows of the
dataframe.
\item \verb{$addSimulationResults()}: In the context of this method, a list of strings
assigning new names to the quantities or paths present in the entered
\code{SimulationResults} object.
\item \verb{$addDataSets()}: In the context of this method, a list of strings
assigning new names to the list of instances of the \code{DataSet} object.
}

Note that the datasets whose names you wish to not change should be specified
as \code{NULL} in the list.}

\item{\code{groups}}{A string or a list of strings assigning the data set to a
group. If an entry within the list is \code{NULL}, the corresponding data set is
not assigned to any group (and the corresponding entry in the dataframe
will be an \code{NA}). If provided, \code{groups} must have the same length as
\code{dataSets} and/or \code{simulationResults}. If no grouping is specified for any
of the dataset, the column \code{group} in the dataframe output will be all
\code{NA}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{DataCombined} object containing simulated data.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-setDataTransformations"></a>}}
\if{latex}{\out{\hypertarget{method-setDataTransformations}{}}}
\subsection{Method \code{setDataTransformations()}}{
Transform raw data with required offsets and scale factors.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$setDataTransformations(
  names = NULL,
  xOffsets = 0,
  yOffsets = 0,
  xScaleFactors = 1,
  yScaleFactors = 1
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{names}}{A string or a list of string. This argument will be encountered
across different methods:
\itemize{
\item \verb{$setDataTransformations()}: In the context of this method, a list of names
specifying which observed datasets and/or paths in simulated dataset to
transform with the specified transformations. Default is \code{NULL}, i.e., the
transformations, if any specified, will be applied to all rows of the
dataframe.
\item \verb{$addSimulationResults()}: In the context of this method, a list of strings
assigning new names to the quantities or paths present in the entered
\code{SimulationResults} object.
\item \verb{$addDataSets()}: In the context of this method, a list of strings
assigning new names to the list of instances of the \code{DataSet} object.
}

Note that the datasets whose names you wish to not change should be specified
as \code{NULL} in the list.}

\item{\code{xOffsets, yOffsets, xScaleFactors, yScaleFactors}}{Either a numeric
scalar or a list of numeric quantities specifying offsets and scale
factors to apply to raw values. The default offset is \code{0}, while
default scale factor is \code{1}, i.e., the data will not be modified. If a
list is specified, it should be the same length as \code{names} argument.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A dataframe with respective raw quantities plus offsets
multiplied by the specified scale factors. If error column is present,
it will also be scaled.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-toDataFrame"></a>}}
\if{latex}{\out{\hypertarget{method-toDataFrame}{}}}
\subsection{Method \code{toDataFrame()}}{
A method to extract a dataframe of simulated and/or observed data
(depending on instances of which objects have been added to the object).

Note that the order in which you enter different object doesn't matter
because the returned dataframe is arranged alphabetically by dataset
name.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$toDataFrame()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A dataframe with some or all of the following columns:\preformatted{name
group
dataType
xValues
xDimension
xUnit
yValues
yErrorValues
yDimension
yUnit
yErrorType
yErrorUnit
molWeight
Group Id
lloq
Source
Sheet
Organ
Compartment
Molecule
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Print the object to the console
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
