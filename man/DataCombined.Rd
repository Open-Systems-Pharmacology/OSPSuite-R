% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data-combined.R
\docType{class}
\name{DataCombined}
\alias{DataCombined}
\title{Object combining simulated and observed data}
\description{
A class for storage of simulated and/or observed data, which can be further
used to extract as a dataframe for visualization methods. Additionally, it
allows:
\itemize{
\item Grouping different (simulated and/or observed) datasets with unique
grouping labels. If no grouping is specified, name of the dataset is used as
a grouping column.
\item Transforming data (with given offsets and scale factors).
}
}
\examples{

# load the simulation
simFilePath <- system.file("extdata", "Aciclovir.pkml", package = "ospsuite")
sim <- loadSimulation(simFilePath)
simulationResults <- runSimulations(simulations = sim)

# create a new dataset object
dataSet <- DataSet$new()

# created object with datasets combined
myCombDat <- DataCombined$new()
myCombDat$addSimulationResults(simulationResults)
myCombDat$addDataSets(dataSet)

# print the object
myCombDat
}
\section{Super class}{
\code{\link[ospsuite:Printable]{ospsuite::Printable}} -> \code{DataCombined}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{dataSets}}{Instance (or a \code{list} of instances) of the \code{DataSet}
object(s).}

\item{\code{simulationResults}}{Object of type \code{SimulationResults} produced by
calling \code{runSimulation} on a \code{Simulation} object.}

\item{\code{groupMap}}{A dataframe specifying which data sets have been grouped
together and the name and the nature of the dataset.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{DataCombined$new()}}
\item \href{#method-addSimulationResults}{\code{DataCombined$addSimulationResults()}}
\item \href{#method-addDataSets}{\code{DataCombined$addDataSets()}}
\item \href{#method-setDataTransforms}{\code{DataCombined$setDataTransforms()}}
\item \href{#method-toDataFrame}{\code{DataCombined$toDataFrame()}}
\item \href{#method-print}{\code{DataCombined$print()}}
\item \href{#method-clone}{\code{DataCombined$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Initialize a new instance of the class.
The constructor is empty because we prefer that the users add
\code{SimulationResults} and \code{DataSet} objects separately and individually.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$new()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A new instance of \code{DataCombined} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addSimulationResults"></a>}}
\if{latex}{\out{\hypertarget{method-addSimulationResults}{}}}
\subsection{Method \code{addSimulationResults()}}{
Add simulated data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$addSimulationResults(
  simulationResults,
  groups = NULL,
  names = NULL,
  quantitiesOrPaths = NULL,
  population = NULL,
  individualIds = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{simulationResults}}{Object of type \code{SimulationResults} produced by
calling \code{runSimulation} on a \code{Simulation} object.}

\item{\code{groups}}{A string or a list of strings assigning the data set to a
group. If an entry within the list is \code{NULL}, the corresponding data set is
not assigned to any group. If \code{NULL} (default), data sets are not assigned
to any group, instead their name is used as a grouping column. If provided,
\code{groups} must have the same length as \code{dataSets}.}

\item{\code{names}}{This argument will be encountered across different methods:
\itemize{
\item \verb{$setDataTransforms()}: In the context of this method, a list of names
specifying which observed datasets and/or paths in simulated dataset to
transform. Default is \code{NULL}, i.e., the transformations will be applied to
all rows of the dataframe.
\item \verb{$addSimulationResults()}: In the context of this method, a list of strings
assigning new names to the quantities or paths present in the entered
\code{SimulationResults} object.
\item \verb{$addDataSets()}: In the context of this method, a list of strings
assigning new names to the list of instances of the \code{DataSet} object.
}

Note that the datasets whose names you wish to not change should be specified
as \code{NULL} in the list.}

\item{\code{quantitiesOrPaths}}{Quantity instances (element or list) typically
retrieved using \code{getAllQuantitiesMatching} or quantity path (element or
list of strings) for which the results are to be returned. (optional)
When providing the paths, only absolute full paths are supported (i.e., no
matching with '*' possible). If \code{quantitiesOrPaths} is \code{NULL} (default
value), returns the results for all output defined in the results.}

\item{\code{population}}{population used to calculate the \code{simulationResults}
(optional). This is used only to add the population covariates to the
resulting dataframe.}

\item{\code{individualIds}}{Numeric IDs of individuals for which the results
should be extracted. By default, all individuals from the results are
considered. If the individual with the provided ID is not found, the ID is
ignored.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{DataCombined} object containing simulated data.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addDataSets"></a>}}
\if{latex}{\out{\hypertarget{method-addDataSets}{}}}
\subsection{Method \code{addDataSets()}}{
Add observed data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$addDataSets(dataSets, groups = NULL, names = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataSets}}{Instance (or a \code{list} of instances) of the \code{DataSet}
object(s).}

\item{\code{groups}}{A string or a list of strings assigning the data set to a
group. If an entry within the list is \code{NULL}, the corresponding data set is
not assigned to any group. If \code{NULL} (default), data sets are not assigned
to any group, instead their name is used as a grouping column. If provided,
\code{groups} must have the same length as \code{dataSets}.}

\item{\code{names}}{This argument will be encountered across different methods:
\itemize{
\item \verb{$setDataTransforms()}: In the context of this method, a list of names
specifying which observed datasets and/or paths in simulated dataset to
transform. Default is \code{NULL}, i.e., the transformations will be applied to
all rows of the dataframe.
\item \verb{$addSimulationResults()}: In the context of this method, a list of strings
assigning new names to the quantities or paths present in the entered
\code{SimulationResults} object.
\item \verb{$addDataSets()}: In the context of this method, a list of strings
assigning new names to the list of instances of the \code{DataSet} object.
}

Note that the datasets whose names you wish to not change should be specified
as \code{NULL} in the list.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{DataCombined} object containing observed data.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-setDataTransforms"></a>}}
\if{latex}{\out{\hypertarget{method-setDataTransforms}{}}}
\subsection{Method \code{setDataTransforms()}}{
Transform raw data with required offsets and scale factors.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$setDataTransforms(
  names = NULL,
  xOffsets = 0,
  yOffsets = 0,
  xScaleFactors = 1,
  yScaleFactors = 1
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{names}}{This argument will be encountered across different methods:
\itemize{
\item \verb{$setDataTransforms()}: In the context of this method, a list of names
specifying which observed datasets and/or paths in simulated dataset to
transform. Default is \code{NULL}, i.e., the transformations will be applied to
all rows of the dataframe.
\item \verb{$addSimulationResults()}: In the context of this method, a list of strings
assigning new names to the quantities or paths present in the entered
\code{SimulationResults} object.
\item \verb{$addDataSets()}: In the context of this method, a list of strings
assigning new names to the list of instances of the \code{DataSet} object.
}

Note that the datasets whose names you wish to not change should be specified
as \code{NULL} in the list.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A dataframe with respective raw quantities plus offsets
multiplied by the specified scale factors.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-toDataFrame"></a>}}
\if{latex}{\out{\hypertarget{method-toDataFrame}{}}}
\subsection{Method \code{toDataFrame()}}{
A dataframe of simulated and/or observed data (depending on instances of
which objects have been added to the object).

Note that the order in which you enter different object matters. If you
first enter observed data and simulated data later, the rows will also be
ordered in the same way.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$toDataFrame()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A dataframe.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Print the object to the console
If \code{dataSets} is a list of \code{DataSet} objects, then the print output is
going to be quite long.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DataCombined$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
