#' @title Extracting simulated values
#'
#' @return
#'
#' Returns the simulated values for the selected outputs (e.g molecules or
#' parameters).
#'
#' @description
#'
#' The function receives an object of simulation results generated by running
#' the simulation and returns time-values profiles for the chosen quantities.
#' Results of a simulation of a single individual is treated as a population
#' simulation with only one individual.
#'
#' @param simulationResults Object of type `SimulationResults` produced by
#'   calling `runSimulation` on a `Simulation` object.
#' @param quantitiesOrPaths Quantity instances (element or vector) typically
#'   retrieved using `getAllQuantitiesMatching` or quantity path (element or
#'   vector of strings) for which the results are to be returned. (optional)
#'   When providing the paths, only absolute full paths are supported (i.e., no
#'   matching with '*' possible). If quantitiesOrPaths is `NULL` (default
#'   value), returns the results for all output defined in the results.
#' @param individualIds `numeric` IDs of individuals for which the results
#'   should be extracted. By default, all individuals from the results are
#'   considered. If the individual with the provided ID is not found, the ID is
#'   ignored.
#' @param population population used to calculate the `simulationResults`
#'   (optional). This is used only to add the population covariates to the
#'   resulting data table.
#' @param stopIfNotFound If `TRUE` (default) an error is thrown if no results
#'   exist for any `path`. If `FALSE`, a list of `NA` values is returned for the
#'   respective path.
#' @param addMetaData If `TRUE` (default), the output is a list two sublists
#'   `data`and `metaData`, with latter storing information about units and
#'   dimensions of the outputs. If `FALSE`, `metaData` is `NULL`. Setting this
#'   option to `FALSE` might improve the performance of the function.
#'
#' @examples
#' library(ospsuite)
#'
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#' sim <- loadSimulation(simPath)
#'
#' # Running an individual simulation
#' # results is an instance of `SimulationResults`
#' results <- runSimulation(sim)
#'
#' getOutputValues(results)
#' @export
getOutputValues <- function(simulationResults,
                            quantitiesOrPaths = NULL,
                            population = NULL,
                            individualIds = NULL,
                            stopIfNotFound = TRUE,
                            addMetaData = TRUE) {
  validateIsOfType(simulationResults, "SimulationResults")
  validateIsOfType(population, "Population", nullAllowed = TRUE)
  validateIsNumeric(individualIds, nullAllowed = TRUE)
  validateIsOfType(quantitiesOrPaths, c("Quantity", "character"), nullAllowed = TRUE)

  quantitiesOrPaths <- quantitiesOrPaths %||% simulationResults$allQuantityPaths
  quantitiesOrPaths <- c(quantitiesOrPaths)

  if (length(quantitiesOrPaths) == 0) {
    return(list(data = NULL, metaData = NULL))
  }

  # If quantities are provided, get their paths
  paths <- vector("character", length(quantitiesOrPaths))
  if (isOfType(quantitiesOrPaths, "Quantity")) {
    for (idx in seq_along(quantitiesOrPaths)) {
      paths[[idx]] <- quantitiesOrPaths[[idx]]$path
    }
  } else {
    paths <- quantitiesOrPaths
  }
  paths <- unique(paths)

  # If no specific individual ids are passed, iterate through all individuals
  individualIds <- ifNotNull(individualIds, unique(individualIds), simulationResults$allIndividualIds)

  # All time values are equal
  timeValues <- simulationResults$timeValues
  valueLength <- length(timeValues)
  covariateNames <- ifNotNull(population, population$allCovariateNames, NULL)

  individualPropertiesCache <- vector("list", length(individualIds))
  # create a cache of all individual values that are constant independent from the path
  for (individualIndex in seq_along(individualIds)) {
    individualId <- individualIds[individualIndex]
    individualProperties <- list(IndividualId = rep(individualId, valueLength))

    for (covariateName in covariateNames) {
      covariateValue <- population$getCovariateValue(covariateName, individualId)
      individualProperties[[covariateName]] <- rep(covariateValue, valueLength)
    }

    individualProperties$Time <- timeValues
    # Save one data frame with all individual properties per individual so that we can easily concatenate them
    individualPropertiesCache[[individualIndex]] <- individualProperties
  }

  # Cache of all individual properties over all individual that will be duplicated in all resulting data.frame
  allIndividualProperties <- do.call(rbind.data.frame, c(individualPropertiesCache, stringsAsFactors = FALSE))

  values <- lapply(paths, function(path) {
    simulationResults$getValuesByPath(path, individualIds, stopIfNotFound)
  })
  names(values) <- paths

  # Use low-level methods to get unit and dimension
  task <- .getContainerTask()
  metaData <- NULL
  if (addMetaData) {
    metaData <- lapply(paths, function(path) {
      unit <- NULL
      dimension <- NULL
      # Get the dimension and unit from path if the results are obtained. If the results
      # are NA, the entity with such path does not exist
      if (!all(is.na(values[[path]]))) {
        unit <- rClr::clrCall(task, "BaseUnitNameByPath", simulationResults$simulation$ref, enc2utf8(path), stopIfNotFound)
        dimension <- rClr::clrCall(task, "DimensionNameByPath", simulationResults$simulation$ref, enc2utf8(path), stopIfNotFound)
      }
      list(unit = unit, dimension = dimension)
    })
    names(metaData) <- paths
    metaData[["Time"]] <- list(unit = "min", dimension = "Time")
  }

  data <- data.frame(allIndividualProperties, values, stringsAsFactors = FALSE, check.names = FALSE)
  return(list(data = data, metaData = metaData))
}

#' Saves the simulation results to csv file
#'
#' @param results Results to export (typically calculated using `runSimulation`
#'   or imported from file).
#' @param filePath Full path where the results will be saved.
#'
#' @examples
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#'
#' # Load the simulation
#' sim <- loadSimulation(simPath)
#'
#' # Add some outputs to the simulation
#' addOutputs("Organism|**|*", sim)
#'
#' # Run the simulation
#' results <- runSimulation(sim)
#'
#' # Export the results to csv file
#' exportResultsToCSV(results, tempfile())
#' @export
exportResultsToCSV <- function(results, filePath) {
  validateIsOfType(results, "SimulationResults")
  validateIsString(filePath)
  filePath <- expandPath(filePath)
  simulationResultsTask <- .getNetTask("SimulationResultsTask")
  rClr::clrCall(simulationResultsTask, "ExportResultsToCSV", results$ref, results$simulation$ref, filePath)
  invisible()
}

#' @inherit exportResultsToCSV
saveResultsToCSV <- function(results, filePath) {
  exportResultsToCSV(results, filePath)
}

#' Imports the simulation results from one or more csv files
#'
#' @param simulation Instance of a simulation used to calculate the results
#' @param filePaths Full path of result files to import. Typically only one
#' file is provided but a list of files is sometimes available when the simulation
#' was parallelized and computed on different machines
#'
#' @examples
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#' resultPath <- system.file("extdata", "res.csv", package = "ospsuite")
#'
#' # Load the simulation
#' sim <- loadSimulation(simPath)
#'
#' # Run the simulation
#' results <- importResultsFromCSV(sim, resultPath)
#' @export
importResultsFromCSV <- function(simulation, filePaths) {
  validateIsOfType(simulation, "Simulation")
  validateIsString(filePaths)
  simulationResultsTask <- .getNetTask("SimulationResultsTask")
  filePaths <- unlist(lapply(filePaths, function(filePath) expandPath(filePath)), use.names = FALSE)

  results <- rClr::clrCall(simulationResultsTask, "ImportResultsFromCSV", simulation$ref, filePaths)
  SimulationResults$new(results, simulation)
}


#' Converts a `SimulationResults` objects to a data.frame
#'
#' @inheritParams getOutputValues
#'
#' @examples
#' library(ospsuite)
#'
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#' sim <- loadSimulation(simPath)
#'
#' # Running an individual simulation
#' # results is an instance of `SimulationResults`
#' results <- runSimulation(sim)
#'
#' # convert to a dataframe
#' simulationResultsToDataFrame(results)
#' @return
#'
#' SimulationResults object as data.frame with columns IndividualId, Time, paths,
#' simulationValues, unit, dimension, TimeUnit.
#'
#' @export
simulationResultsToDataFrame <- function(simulationResults,
                                         quantitiesOrPaths = NULL,
                                         population = NULL,
                                         individualIds = NULL) {
  # no need to validating the input because this will be done by
  # getOutputValues() anyways
  simList <- getOutputValues(
    simulationResults = simulationResults,
    quantitiesOrPaths = quantitiesOrPaths,
    population        = population,
    individualIds     = individualIds
  )

  # convert data to long format with a new column for paths
  df_data <- tidyr::pivot_longer(
    simList$data,
    cols = -c("IndividualId", "Time"),
    names_to = "paths",
    values_to = "simulationValues"
  )

  # extract units and dimensions for paths in a separate dataframe
  # iterate over the list (in .x) using index (names for list elements)
  # and apply function in .f to each elements
  # the result will be a list of dataframes, which will be bound into
  # a single dataframe with the _dfr variant of this function
  df_meta <- purrr::imap_dfr(
    .x = simList$metaData,
    .f = ~ as.data.frame(.x, row.names = NULL, stringsAsFactors = FALSE),
    .id = "paths"
  )

  # leave out time units and dimensions since it is not a path
  # they will be added at a later stage
  df_meta <- dplyr::filter(df_meta, paths != "Time")

  # combine dataframe with simulated data and meta data
  df <- dplyr::left_join(df_data, df_meta, by = "paths")

  # now add previously left out time meta data to the combined dataframe
  df <- dplyr::bind_cols(
    df,
    dplyr::tibble(
      "TimeUnit" = simList$metaData$Time$unit[[1]],
      "TimeDimension" = simList$metaData$Time$dimension[[1]]
    )
  )

  # For each path, extract the molecular weight based on that path string
  #
  # This involves first grouping and nesting the data by path. Note that
  # `nest()` here will have a better performance than `rowwise()`. E.g., if
  # there are 100 rows, `rowwise()` will run the compuation 100 times, while
  # with `nest()`, the computation only be carried for the same number of
  # times as the number of `paths` present.
  #
  # And then adding a new column for molecular weight.
  #
  # When you call `molWeightFor()`, it returns the value in the base unit -
  # which is `kg/Âµmol`. This is not the unit the user would expect, so we
  # convert it first to the common unit `g/mol`
  df <- df %>%
    dplyr::group_by(paths) %>%
    tidyr::nest() %>%
    dplyr::mutate(
      molWeight = ospsuite::toUnit(
        quantityOrDimension = ospDimensions$`Molecular weight`,
        values              = simulationResults$simulation$molWeightFor(paths),
        targetUnit          = ospUnits$`Molecular weight`$`g/mol`
      )
    ) %>%
    tidyr::unnest(cols = c(data)) %>%
    dplyr::ungroup()

  # consistently return a (classical) data frame
  return(as.data.frame(df, stringsAsFactors = FALSE))
}

#' @rdname simulationResultsToDataFrame
#'
#' @export
simulationResultsToTibble <- function(simulationResults,
                                      quantitiesOrPaths = NULL,
                                      population = NULL,
                                      individualIds = NULL) {
  df <- simulationResultsToDataFrame(
    simulationResults = simulationResults,
    quantitiesOrPaths = quantitiesOrPaths,
    population = population,
    individualIds = individualIds
  )

  # consistently return a tibble data frame
  return(dplyr::as_tibble(df))
}
