#' Helper function to normalize SimulationResults input
#' @description Converts single SimulationResults to a list, validates lists of SimulationResults
#' @param simulationResults Single SimulationResults object or list of SimulationResults objects
#' @return A list of SimulationResults objects and a logical indicating if input was a list
#' @keywords internal
.normalizeSimulationResults <- function(simulationResults) {
  # If it's a list, validate all elements are SimulationResults
  if (is.list(simulationResults)) {
    # Check if it's actually a SimulationResults object (which is also a list internally)
    if (inherits(simulationResults, "SimulationResults")) {
      # Single SimulationResults object
      return(list(list = list(simulationResults), wasList = FALSE))
    }
    # It's a list of objects - validate each one
    lapply(simulationResults, function(x) {
      validateIsOfType(x, "SimulationResults")
    })
    return(list(list = simulationResults, wasList = TRUE))
  } else {
    # Single SimulationResults object
    validateIsOfType(simulationResults, "SimulationResults")
    return(list(list = list(simulationResults), wasList = FALSE))
  }
}

#' @title Extracting simulated values
#'
#' @return
#'
#' Returns the simulated values for the selected outputs (e.g molecules or
#' parameters). If a list of `SimulationResults` is provided, returns a named
#' list where each element corresponds to one `SimulationResults` object.
#'
#' @description
#'
#' The function receives an object or list of simulation results generated by running
#' the simulation and returns time-values profiles for the chosen quantities.
#' Results of a simulation of a single individual is treated as a population
#' simulation with only one individual.
#'
#' @template simulation_results
#' @param stopIfNotFound If `TRUE` (default) an error is thrown if no results
#'   exist for any `path`. If `FALSE`, a list of `NA` values is returned for the
#'   respective path.
#' @param addMetaData If `TRUE` (default), the output is a list two sublists
#'   `data`and `metaData`, with latter storing information about units and
#'   dimensions of the outputs. If `FALSE`, `metaData` is `NULL`. Setting this
#'   option to `FALSE` might improve the performance of the function.
#'
#' @examples
#' library(ospsuite)
#'
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#' sim <- loadSimulation(simPath)
#'
#' # Running an individual simulation
#' # results is an instance of `SimulationResults`
#' results <- runSimulations(sim)[[1]]
#'
#' getOutputValues(results)
#'
#' # Working with a list of SimulationResults
#' results <- runSimulations(sim)
#' outputList <- getOutputValues(results)
#' @export
getOutputValues <- function(
  simulationResults,
  quantitiesOrPaths = NULL,
  population = NULL,
  individualIds = NULL,
  stopIfNotFound = TRUE,
  addMetaData = TRUE
) {
  # Normalize input - convert single to list or validate list
  normalized <- .normalizeSimulationResults(simulationResults)
  resultsList <- normalized$list
  wasList <- normalized$wasList
  
  validateIsOfType(population, "Population", nullAllowed = TRUE)
  validateIsNumeric(individualIds, nullAllowed = TRUE)
  validateIsOfType(
    quantitiesOrPaths,
    c("Quantity", "character"),
    nullAllowed = TRUE
  )

  # Process each SimulationResults object
  outputList <- lapply(seq_along(resultsList), function(i) {
    currentResult <- resultsList[[i]]
    
    currentQuantitiesOrPaths <- quantitiesOrPaths %||% currentResult$allQuantityPaths
    currentQuantitiesOrPaths <- c(currentQuantitiesOrPaths)
    
    if (length(currentQuantitiesOrPaths) == 0) {
      return(list(data = NULL, metaData = NULL))
    }
    
    # If quantities are provided, get their paths
    paths <- .entitiesToPaths(currentQuantitiesOrPaths)
    # If no specific individual ids are passed, iterate through all individuals
    currentIndividualIds <- ifNotNull(
      individualIds,
      unique(individualIds),
      currentResult$allIndividualIds
    )
    
    # All time values are equal
    timeValues <- currentResult$timeValues
    valueLength <- length(timeValues)
    covariateNames <- ifNotNull(population, population$allCovariateNames, NULL)
    
    individualPropertiesCache <- vector("list", length(currentIndividualIds))
    # create a cache of all individual values that are constant independent from the path
    for (individualIndex in seq_along(currentIndividualIds)) {
      individualId <- currentIndividualIds[individualIndex]
      individualProperties <- list(IndividualId = rep(individualId, valueLength))
      
      for (covariateName in covariateNames) {
        covariateValue <- population$getCovariateValue(
          covariateName,
          individualId
        )
        individualProperties[[covariateName]] <- rep(covariateValue, valueLength)
      }
      
      individualProperties$Time <- timeValues
      # Save one data frame with all individual properties per individual so that we can easily concatenate them
      individualPropertiesCache[[individualIndex]] <- individualProperties
    }
    
    # Cache of all individual properties over all individual that will be duplicated in all resulting data.frame
    allIndividualProperties <- do.call(
      rbind.data.frame,
      c(individualPropertiesCache, stringsAsFactors = FALSE)
    )
    values <- lapply(paths, function(path) {
      currentResult$getValuesByPath(path, currentIndividualIds, stopIfNotFound)
    })
    names(values) <- paths
    
    # Use low-level methods to get unit and dimension
    task <- .getNetTaskFromCache("ContainerTask")
    metaData <- NULL
    if (addMetaData) {
      metaData <- lapply(paths, function(path) {
        unit <- NULL
        dimension <- NULL
        # Get the dimension and unit from path if the results are obtained. If the results
        # are NA, the entity with such path does not exist
        if (!all(is.na(values[[path]]))) {
          unit <- task$call(
            "BaseUnitNameByPath",
            currentResult$simulation,
            path,
            stopIfNotFound
          )
          dimension <- task$call(
            "DimensionNameByPath",
            currentResult$simulation,
            path,
            stopIfNotFound
          )
        }
        list(unit = unit, dimension = dimension)
      })
      names(metaData) <- paths
      metaData[["Time"]] <- list(unit = "min", dimension = "Time")
    }
    
    data <- data.frame(
      allIndividualProperties,
      values,
      stringsAsFactors = FALSE,
      check.names = FALSE
    )
    return(list(data = data, metaData = metaData))
  })
  
  # Name the output list using the names from the input list
  names(outputList) <- names(resultsList)
  
  # If input was a single SimulationResults, return single result (not list)
  if (!wasList) {
    return(outputList[[1]])
  }
  
  return(outputList)
}

#' Saves the simulation results to csv file
#'
#' @param results Results to export. Can be a single `SimulationResults` object
#'   or a list containing exactly one `SimulationResults` object (typically the
#'   output from `runSimulations` for a single simulation).
#' @param filePath Full path where the results will be saved.
#'
#' @examples
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#'
#' # Load the simulation
#' sim <- loadSimulation(simPath)
#'
#' # Add some outputs to the simulation
#' addOutputs("Organism|**|*", sim)
#'
#' # Run the simulation - can export directly without [[1]]
#' results <- runSimulations(sim)
#' exportResultsToCSV(results, tempfile())
#'
#' # Or with explicit indexing
#' results <- runSimulations(sim)[[1]]
#' exportResultsToCSV(results, tempfile())
#' @export
exportResultsToCSV <- function(results, filePath) {
  # Normalize input
  normalized <- .normalizeSimulationResults(results)
  resultsList <- normalized$list
  
  # Only allow single SimulationResults object
  if (length(resultsList) > 1) {
    stop(messages$errorExportResultsOnlyOneObject())
  }
  
  # Extract the single result
  singleResult <- resultsList[[1]]
  
  validateIsString(filePath)
  filePath <- .expandPath(filePath)
  simulationResultsTask <- .getNetTask("SimulationResultsTask")
  simulationResultsTask$call(
    "ExportResultsToCSV",
    singleResult,
    singleResult$simulation,
    filePath
  )
  invisible()
}

#' @inherit exportResultsToCSV
.saveResultsToCSV <- function(results, filePath) {
  exportResultsToCSV(results, filePath)
}

#' Imports the simulation results from one or more csv files
#'
#' @param simulation Instance of a simulation used to calculate the results
#' @param filePaths Full path of result files to import. Typically only one
#' file is provided but a list of files is sometimes available when the simulation
#' was parallelized and computed on different machines
#'
#' @examples
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#' resultPath <- system.file("extdata", "res.csv", package = "ospsuite")
#'
#' # Load the simulation
#' sim <- loadSimulation(simPath)
#'
#' # Run the simulation
#' results <- importResultsFromCSV(sim, resultPath)
#' @export
importResultsFromCSV <- function(simulation, filePaths) {
  validateIsOfType(simulation, "Simulation")
  validateIsString(filePaths)
  simulationResultsTask <- .getNetTask("SimulationResultsTask")
  filePaths <- unlist(
    lapply(filePaths, function(filePath) .expandPath(filePath)),
    use.names = FALSE
  )

  results <- simulationResultsTask$call(
    "ImportResultsFromCSV",
    simulation,
    filePaths
  )
  SimulationResults$new(results, simulation)
}


#' Converts a `SimulationResults` objects to a data.frame
#'
#' @inheritParams getOutputValues
#'
#' @examples
#' library(ospsuite)
#'
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#' sim <- loadSimulation(simPath)
#'
#' # Running an individual simulation
#' # results is an instance of `SimulationResults`
#' results <- runSimulations(sim)[[1]]
#'
#' # convert to a dataframe
#' simulationResultsToDataFrame(results)
#'
#' # Working with a list of SimulationResults
#' results <- runSimulations(sim)
#' dfList <- simulationResultsToDataFrame(results)
#' @return
#'
#' If a single `SimulationResults` object is provided, returns a data.frame
#' with columns IndividualId, Time, paths, simulationValues, unit, dimension,
#' TimeUnit, TimeDimension, molWeight.
#'
#' If a list of `SimulationResults` is provided, returns a named list of
#' data.frames, one for each `SimulationResults` object.
#'
#' @export
simulationResultsToDataFrame <- function(
  simulationResults,
  quantitiesOrPaths = NULL,
  population = NULL,
  individualIds = NULL
) {
  # Normalize input to determine if we received a list
  normalized <- .normalizeSimulationResults(simulationResults)
  resultsList <- normalized$list
  wasList <- normalized$wasList
  
  # getOutputValues will now handle the list processing
  simList <- getOutputValues(
    simulationResults = simulationResults,
    quantitiesOrPaths = quantitiesOrPaths,
    population = population,
    individualIds = individualIds
  )
  
  # If input was a list, simList is a list of results
  if (wasList) {
    dfList <- lapply(seq_along(simList), function(i) {
      currentSimList <- simList[[i]]
      currentResult <- resultsList[[i]]
      
      # use data.table to pivot simList$data to long format
      simData <- data.table::melt(
        as.data.table(currentSimList$data),
        id.vars = c("IndividualId", "Time"),
        variable.name = "paths",
        value.name = "simulationValues",
        variable.factor = FALSE
      )
      
      # set order of simData by Time
      simData <- data.table::setorder(simData, Time)
      
      # add columns to simData
      simData <- simData[,
        `:=`(
          TimeDimension = currentSimList$metaData$Time$dimension,
          TimeUnit = currentSimList$metaData$Time$unit,
          dimension = currentSimList$metaData[[paths]]$dimension,
          unit = currentSimList$metaData[[paths]]$unit,
          molWeight = toUnit(
            quantityOrDimension = ospDimensions$`Molecular weight`,
            values = currentResult$simulation$molWeightFor(paths),
            targetUnit = ospUnits$`Molecular weight`$`g/mol`
          )
        ),
        by = paths
      ]
      
      # consistently return a (classical) data frame
      as.data.frame(simData, stringsAsFactors = FALSE)
    })
    names(dfList) <- names(resultsList)
    return(dfList)
  }
  
  # Single result - original behavior
  # use data.table to pivot simList$data to long format, all columns except
  # "IndividualId" and "Time" to "paths" column and their value to
  # "simulationValues"
  simData <-
    data.table::melt(
      as.data.table(simList$data),
      id.vars = c("IndividualId", "Time"),
      variable.name = "paths",
      value.name = "simulationValues",
      variable.factor = FALSE
    )

  # set order of simData by Time
  simData <- data.table::setorder(simData, Time)

  # add columns to simData
  simData <- simData[,
    `:=`(
      TimeDimension = simList$metaData$Time$dimension,
      TimeUnit = simList$metaData$Time$unit,
      dimension = simList$metaData[[paths]]$dimension,
      unit = simList$metaData[[paths]]$unit,
      molWeight = toUnit(
        quantityOrDimension = ospDimensions$`Molecular weight`,
        values = resultsList[[1]]$simulation$molWeightFor(paths),
        targetUnit = ospUnits$`Molecular weight`$`g/mol`
      )
    ),
    by = paths
  ]

  # # consistently return a (classical) data frame
  return(as.data.frame(simData, stringsAsFactors = FALSE))
}


#' @rdname simulationResultsToDataFrame
#'
#' @export
simulationResultsToTibble <- function(
  simulationResults,
  quantitiesOrPaths = NULL,
  population = NULL,
  individualIds = NULL
) {
  simData <- simulationResultsToDataFrame(
    simulationResults = simulationResults,
    quantitiesOrPaths = quantitiesOrPaths,
    population = population,
    individualIds = individualIds
  )
  
  # If input was a list, simData is a list of data.frames
  if (is.list(simData) && !is.data.frame(simData)) {
    return(lapply(simData, dplyr::as_tibble))
  }

  # consistently return a tibble data frame
  return(dplyr::as_tibble(simData))
}
